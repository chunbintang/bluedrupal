<?php
/**
 * @file
 * Drupal stream wrapper implementation for OpenStack Storage
 *
 * Implements DrupalStreamWrapperInterface to host files on OpenStack
 * storage.
 */

class OpenStackStorageDrupalStreamWrapper implements DrupalStreamWrapperInterface {
  /**
   * @var String Instance URI referenced as "stream://key"
   */
  protected $uri;

  /**
   * @var object The Store instance of the OpenStack Storage.
   */
  protected $store;

  /**
   * @var array directory listing
   */
  protected $dir = array();

  /**
   * @var array Default map for determining file mime types
   */
  protected static $mapping = NULL;

  /**
   * @var array Buffer for streams.
   */
  protected $writeBuffer;

  /**
   * @var object File object contents.
   */
  protected $objectContent;

  /**
   * Sets the stream resource URI.
   *
   * URIs are formatted as "stream://key"
   *
   * @return string
   *   Returns the current URI of the instance.
   */
  public function setUri($uri) {
    $this->uri = $uri;
  }

  /**
   * Returns the stream resource URI.
   *
   * URIs are formatted as "stream://key"
   *
   * @return string
   *   Returns the current URI of the instance.
   */
  public function getUri() {
    return $this->uri;
  }

  /**
   * Returns the local writable target of the resource within the stream.
   *
   * This function should be used in place of calls to realpath() or similar
   * functions when attempting to determine the location of a file. While
   * functions like realpath() may return the location of a read-only file, this
   * method may return a URI or path suitable for writing that is completely
   * separate from the URI used for reading.
   *
   * @param string $uri
   *   Optional URI.
   *
   * @return string
   *   Returns a string representing a location suitable for writing of a file,
   *   or FALSE if unable to write to the file such as with read-only streams.
   */
  protected function getTarget($uri = NULL) {
    if (!isset($uri)) {
      $uri = $this->uri;
    }

    $data = self::uriToData($uri);
    return $data['object'];
  }

  /**
   * Implements getMimeType().
   */
  public static function getMimeType($uri, $mapping = NULL) {
    // Load the default file map.
    if (!isset(self::$mapping)) {
      include_once DRUPAL_ROOT . '/includes/file.mimetypes.inc';
      self::$mapping = file_mimetype_mapping();
    }

    $extension = '';
    $file_parts = explode('.', basename($uri));

    // Remove the first part: a full filename should not match an extension.
    array_shift($file_parts);

    // Iterate over the file parts, trying to find a match.
    // For my.awesome.image.jpeg, we try:
    // jpeg
    // image.jpeg, and
    // awesome.image.jpeg
    while ($additional_part = array_pop($file_parts)) {
      $extension = strtolower($additional_part . ($extension ? '.' . $extension : ''));
      if (isset(self::$mapping['extensions'][$extension])) {
        return self::$mapping['mimetypes'][self::$mapping['extensions'][$extension]];
      }
    }

    return 'application/octet-stream';
  }

  /**
   * Implements getDirectoryPath().
   *
   * In this case there is no directory string, so return an empty string.
   */
  public function getDirectoryPath() {
    $data = self::uriToData($this->uri);

    if ($data['scheme'] == 'public') {
      return variable_get('file_public_path', conf_path() . '/files');
    }
    elseif ($data['scheme'] == 'private') {
      return variable_get('file_private_path', '');
    }

    return '';
  }

  /**
   * Overrides getExternalUrl().
   */
  public function getExternalUrl() {
    $data = self::uriToData($this->uri);

    // Private files are served through Drupal.
    if ($data['scheme'] == 'private') {
      try  {
        $objectData = $this->getOpenStackObjectData($this->uri);
        // 10 MB
        if ( $objectData['size'] > 1024*1024*10) {
          $object = $this->getOpenStackPartialObject($this->uri);

          if ($object) {
            // Valid 30 minutes
            return $object->getTemporaryUrl(60*30, 'GET');
          }
        }
      }
      catch (Exception $e) {
        // Just use the system url.
      }

      return url('system/files/' . $data['object'], array('absolute' => TRUE));
    }

    try {
      $data = $this->getOpenStackObjectData($this->uri);
      return $data['url'];
    }
    catch (Exception $e) {
      // This could be a file which still needs to be generated by
      // Drupal. Return the normal uri.
      return $GLOBALS['base_url'] . '/' . variable_get('file_public_path', conf_path() . '/files') . '/' . $data['object'];
    }
  }

  /**
   * We have no concept of chmod, so just return TRUE.
   */
  public function chmod($mode) {
    return TRUE;
  }

  /**
   * Returns canonical, absolute path of the resource on the local fs.
   *
   * @return bool
   *   Returns FALSE as this wrapper does not provide an implementation.
   */
  public function realpath() {
    return FALSE;
  }

  /**
   * Support for fopen(), file_get_contents(), file_put_contents() etc.
   *
   * @param string $uri
   *   A string containing the URI to the file to open.
   * @param string $mode
   *   The file mode ("r", "wb" etc.).
   * @param int $options
   *   A bit mask of STREAM_USE_PATH and STREAM_REPORT_ERRORS.
   * @param string $opened_path
   *   A string containing the path actually opened.
   *
   * @return bool
   *   Returns TRUE if file was opened successfully.
   *
   * @see http://php.net/manual/en/streamwrapper.stream-open.php
   */
  public function stream_open($uri, $mode, $options, &$opened_path) {
    $this->uri = $uri;

    // If this stream is being opened for writing, clear the object buffer.
    // Return true as we'll create the object on fflush call.
    if (strpbrk($mode, 'wax')) {
      $this->clearBuffer();
      return TRUE;
    }

    // Read stream.
    try {
      $object = $this->getOpenStackObject($this->uri);
      $this->objectContent = $object->getContent();
      $this->objectContent->rewind();

      return TRUE;
    }
    catch (Exception $e) {
      return FALSE;
    }
  }

  /**
   * Support for flock().
   *
   * @param string $operation
   *   One of the following:
   *   - LOCK_SH to acquire a shared lock (reader).
   *   - LOCK_EX to acquire an exclusive lock (writer).
   *   - LOCK_UN to release a lock (shared or exclusive).
   *   - LOCK_NB if you don't want flock() to block while locking (not
   *     supported on Windows).
   *
   * @return bool
   *   returns TRUE if lock was successful
   *
   * @see http://php.net/manual/en/streamwrapper.stream-lock.php
   */
  public function stream_lock($operation) {
    return FALSE;
  }

  /**
   * Support for fread(), file_get_contents() etc.
   *
   * @param int $count
   *   Maximum number of bytes to be read.
   *
   * @return string
   *   The string that was read, or FALSE in case of an error.
   *
   * @see http://php.net/manual/en/streamwrapper.stream-read.php
   */
  public function stream_read($count) {
    $read = fread($this->objectContent->getStream(), $count);
    return $read;
  }

  /**
   * Support for fwrite(), file_put_contents() etc.
   *
   * @param string $data
   *   The string to be written.
   *
   * @return int
   *   The number of bytes written (integer).
   *
   * @see http://php.net/manual/en/streamwrapper.stream-write.php
   */
  public function stream_write($data) {
    $this->writeBuffer .= $data;
    return strlen($data);
  }

  /**
   * Support for feof().
   *
   * @return bool
   *   TRUE if end-of-file has been reached.
   *
   * @see http://php.net/manual/en/streamwrapper.stream-eof.php
   */
  public function stream_eof() {
    if (!$this->uri) {
      return TRUE;
    }

    return feof($this->objectContent->getStream());
  }

  /**
   * Support for fseek().
   *
   * @param int $offset
   *   The byte offset to got to.
   * @param bit $whence
   *   SEEK_SET, SEEK_CUR, or SEEK_END.
   *
   * @return bool
   *   TRUE on success.
   *
   * @see http://php.net/manual/en/streamwrapper.stream-seek.php
   */
  public function stream_seek($offset, $whence) {
    return fseek($this->objectContent->getStream(), $offset, $whence);
  }

  /**
   * Support for fflush().
   *
   * @return bool
   *   TRUE if data was successfully stored (or there was no data to store).
   *   This always returns TRUE, as this example provides and needs no
   *   flush support.
   *
   * @see http://php.net/manual/en/streamwrapper.stream-flush.php
   */
  public function stream_flush() {
    if (!empty($this->writeBuffer)) {
      $data = self::uriToData($this->uri);

      try {
        $container = $this->getOpenStackContainer($data['container_name']);
        $container->uploadObject($data['object'], $this->writeBuffer);
        cache_clear_all('object-data:' . $this->uri, 'cache_file_openstack');
      }
      catch (Exception $e) {
        $this->clearBuffer();
        return FALSE;
      }
    }

    return TRUE;
  }

  /**
   * Support for ftell().
   *
   * @return int
   *   The current offset in bytes from the beginning of file.
   *
   * @see http://php.net/manual/en/streamwrapper.stream-tell.php
   */
  public function stream_tell() {
    return ftell($this->objectContent->getStream());
  }

  /**
   * Support for fstat().
   *
   * @return array|bool
   *   An array with file status, or FALSE in case of an error - see fstat()
   *   for a description of this array.
   *
   * @see http://php.net/manual/en/streamwrapper.stream-stat.php
   */
  public function stream_stat() {
    return fstat($this->objectContent->getStream());
  }

  /**
   * Support for fclose().
   *
   * @return bool
   *   TRUE if stream was successfully closed.
   *
   * @see http://php.net/manual/en/streamwrapper.stream-close.php
   */
  public function stream_close() {
    $this->clearBuffer();
    return TRUE;
  }

  /**
   * Support for unlink().
   *
   * @param string $uri
   *   A string containing the uri to the resource to delete.
   *
   * @return bool
   *   TRUE if resource was successfully deleted.
   *
   * @see http://php.net/manual/en/streamwrapper.unlink.php
   */
  public function unlink($uri) {
    try {
      $object = $this->getOpenStackObject($uri);
      $object->delete();
      cache_clear_all('object-data:' . $uri, 'cache_file_openstack');
      return TRUE;
    }
    catch (OpenCloud\ObjectStore\Exception\ObjectNotFoundException $e) {
      // If the object can not be found it has already been deleted.
      return TRUE;
    }
    catch (Exception $e) {
      return FALSE;
    }
  }

  /**
   * Support for rename().
   *
   * @param string $from_uri
   *   The uri to the file to rename.
   * @param string $to_uri
   *   The new uri for file.
   *
   * @return bool
   *   TRUE if file was successfully renamed.
   *
   * @see http://php.net/manual/en/streamwrapper.rename.php
   */
  public function rename($from_uri, $to_uri) {
    $data_to = self::uriToData($to_uri);

    try {
      $object = $this->getOpenStackObject($from_uri);

      // Copy the object and delete the old object.
      $object->copy($data_to['container_name'] . '/' . $data_to['object']);
      $object->delete();
    }
    catch (Exception $e) {
      return FALSE;
    }

    return TRUE;
  }

  /**
   * Get a directory-like URI from a base URI.
   *
   * This is the weirdest function. If $path is set, it is presumably
   * a URI. But we don't know anything about this URI, including where
   * it came from or whether we are responsible for handling it.
   *
   * If it's not set, then we use the present object's URI. Seems like
   * this is a misplaced utility function or static method.
   *
   * Finally, what we return isn't a dirname, but a URI with the last
   * item chopped off the path.
   */
  public function dirname($uri = NULL) {
    if ($uri == NULL) {
      $uri = $this->uri;
    }
    $data = self::uriToData($uri);

    // If path is empty or has no slashes, dirname returns '.'.
    $path = dirname($data['object']);
    if ($path == '.') {
      $path = '';
    }

    return $data['scheme'] . '://' . $path;
  }

  /**
   * Support for mkdir().
   *
   * @param string $uri
   *   A string containing the URI to the directory to create.
   * @param int $mode
   *   Permission flags - see mkdir().
   * @param bit $options
   *   A bit mask of STREAM_REPORT_ERRORS and STREAM_MKDIR_RECURSIVE.
   *
   * @return bool
   *   TRUE if directory was successfully created.
   *
   * @see http://php.net/manual/en/streamwrapper.mkdir.php
   */
  public function mkdir($uri, $mode, $options) {
    return TRUE;
  }

  /**
   * Support for rmdir().
   *
   * @param string $uri
   *   A string containing the URI to the directory to delete.
   * @param bit $options
   *   A bit mask of STREAM_REPORT_ERRORS.
   *
   * @return bool
   *   TRUE if directory was successfully removed.
   *
   * @see http://php.net/manual/en/streamwrapper.rmdir.php
   */
  public function rmdir($uri, $options) {
    return TRUE;
  }

  /**
   * Support for stat().
   *
   * This important function goes back to the Unix way of doing things.
   * In this example almost the entire stat array is irrelevant, but the
   * mode is very important. It tells PHP whether we have a file or a
   * directory and what the permissions are. All that is packed up in a
   * bitmask. This is not normal PHP fodder.
   *
   * @param string $uri
   *   A string containing the URI to get information about.
   * @param bit $flags
   *   A bit mask of STREAM_URL_STAT_LINK and STREAM_URL_STAT_QUIET.
   *
   * @return array|bool
   *   An array with file status, or FALSE in case of an error - see fstat()
   *   for a description of this array.
   *
   * @see http://php.net/manual/en/streamwrapper.url-stat.php
   */
  public function url_stat($uri, $flags) {
    static $stats = array();

    try {
      if (isset($stats[$uri])) {
        return $stats[$uri];
      }

      $data = self::uriToData($uri);
      $is_file = self::isFileish($data['object']);

      // Set inode type to directory or file.
      $type = $is_file ? 0100000 : 040000;
      // Fake world-readible
      $mode = $type + 0777;

      $values = array(
        'dev' => 0,
        'ino' => 0,
        'mode' => $mode,
        'nlink' => 0,
        'uid' => posix_getuid(),
        'gid' => posix_getgid(),
        'rdev' => 0,
        'size' => 0,
        'atime' => REQUEST_TIME,
        'mtime' => REQUEST_TIME,
        'ctime' => REQUEST_TIME,
        'blksize' => 0,
        'blocks' => 0,
      );

      // Only do this if we try to get information about a file.
      // Directories always return a true stat because the object store
      // automatically creates these.
      if ($is_file && $data['object'] != '.htaccess') {
        $data = $this->getOpenStackObjectData($uri);

        $values['size'] = $data['size'];
        $values['mtime'] = $data['mtime'];

        // Use mtime because we do not have a ctime.
        $values['ctime'] = $data['mtime'];
      }

      $stats[$uri] = array_values($values) + $values;
      return $stats[$uri];
    }
    catch (Exception $e) {
      return FALSE;
    }
  }

  /**
   * Support for opendir().
   *
   * @param string $uri
   *   A string containing the URI to the directory to open.
   * @param mixed $options
   *   Unknown (parameter is not documented in PHP Manual).
   *
   * @return bool
   *   TRUE on success.
   *
   * @see http://php.net/manual/en/streamwrapper.dir-opendir.php
   */
  public function dir_opendir($uri, $options) {
    $data = self::uriToData($uri);

    // Initialize directory.
    $this->dir = array();
    $this->dir[] = '.';
    $this->dir[] = '..';

    // Retrieve the directory so we can replace that with empty string.
    if (self::isFileish($data['object'])) {
      $dir = dirname($data['object']);
    }
    else {
      $dir = $data['object'];
    }
    try {
      $container = $this->getOpenStackContainer($data['container_name']);
      $options = array(
        'path' => $dir,
      );
      $options['path'] = $dir;

      $files = $container->objectList($options);

      foreach ($files as $file) {
        $file_uri = $uri . $file->getName();
        _openstack_storage_set_cached_object_data($file_uri, array(
          'url' => (string) $file->getUrl(),
          'size' => $file->getContentLength(),
          'mtime' => strtotime($file->getLastModified()),
        ));

        $this->dir[] = str_replace("$dir/", '', $file->getName());
      }
    }
    catch (Exception $e) {
      return FALSE;
    }

    return TRUE;
  }

  /**
   * Support for readdir().
   *
   * @return string|bool
   *   The next filename, or FALSE if there are no more files in the directory.
   *
   * @see http://php.net/manual/en/streamwrapper.dir-readdir.php
   */
  public function dir_readdir() {
    $filename = current($this->dir);
    if ($filename !== FALSE) {
      next($this->dir);
    }
    return $filename;
  }

  /**
   * Support for rewinddir().
   *
   * @return bool
   *   TRUE on success.
   *
   * @see http://php.net/manual/en/streamwrapper.dir-rewinddir.php
   */
  public function dir_rewinddir() {
    reset($this->dir);
    return TRUE;
  }

  /**
   * Support for closedir().
   *
   * @return bool
   *   TRUE on success.
   *
   * @see http://php.net/manual/en/streamwrapper.dir-closedir.php
   */
  public function dir_closedir() {
    $this->dir = array();
    return TRUE;
  }

  /**
   * Parse a URI and determine the container and object for this URI.
   *
   * @param string $uri
   *   The uri of the file or directory.
   *
   * @return array
   *   Returns an array with the following keys:
   *     - container: The name of the container.
   *     - object: The name of the object.
   */
  public static function uriToData($uri) {
    // Retrieve the scheme and path.
    list($scheme, $path) = explode('://', $uri, 2);
    $path = trim($path, '\/');

    return array(
      'container_name' => variable_get('openstack_storage_stream_' . $scheme, '_none'),
      'object' => $path,
      'scheme' => $scheme,
    );
  }

  /**
   * Retrieve an object from the OpenStack Storage.
   *
   * @param string $uri
   *   The uri of the file or directory.
   *
   * @return object
   *   The object retrieved from the storage.
   */
  public function getOpenStackObject($uri) {
    $data = self::uriToData($uri);
    $container = $this->getOpenStackContainer($data['container_name']);
    return $container->getObject($data['object']);
  }

  /**
   * Retrieve object data from the OpenStack Storage.
   *
   * @param string $uri
   *   The uri of the file or directory.
   *
   * @return object
   *   The object retrieved from the storage.
   */
  public function getOpenStackPartialObject($uri) {
    $data = self::uriToData($uri);
    $container = $this->getOpenStackContainer($data['container_name']);
    return $container->getPartialObject($data['object']);
  }

  /**
   * Retrieve the data from an object in the store.
   *
   * @param string $uri
   *   The uri to the file or directory.
   *
   * @return array
   *   Returns an array with the following keys:
   *     - url: The public url of the object.
   *     - size: The size of the object in the store.
   *     - mtime: The last moditifed time as unix timestamp.
   */
  public function getOpenStackObjectData($uri) {
    $data = _openstack_storage_get_cached_object_data($uri);

    if (!$data) {
      $object = $this->getOpenStackPartialObject($uri);

      if ($object) {
        $data = array(
          'url' => (string) $object->getUrl(),
          'size' => $object->getContentLength(),
          'mtime' => strtotime($object->getLastModified()),
        );

        cache_set('object-data:' . $uri, $data, 'cache_file_openstack');
      }
      else {
        return FALSE;
      }
    }

    return $data;
  }

  /**
   * Retrieve the container from the OpenStack Storage.
   *
   * @param string $container_name
   *   The container name in the OpenStack storage.
   *
   * @return object
   *   Returns the container object from the storage.
   */
  public function getOpenStackContainer($container_name) {
    static $containers = array();

    if (!isset($containers[$container_name])) {
      if (!$this->store) {
        $this->store = _openstack_storage_get_object_store();
      }

      $containers[$container_name] = $this->store->getContainer($container_name);
    }

    return $containers[$container_name];
  }

  /**
   * Clears the buffers.
   */
  public function clearBuffer() {
    $this->writeBuffer = '';

    if ($this->objectContent) {
      fclose($this->objectContent->getStream());
    }
    $this->objectContent = FALSE;
  }

  /**
   * Detects whether a uri is a file.
   *
   * @param string $path
   *   The uri of the file or directory.
   *
   * @return bool
   *   Returns or it's a file or not.
   */
  public static function isFileish($path) {
    $ext = pathinfo($path, PATHINFO_EXTENSION);

    return !empty($ext);
  }
}
